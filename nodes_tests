from enum import Enum

class TextType(Enum):
    PLAIN_TEXT = "plain"
    BOLD_TEXT = "bold"
    ITALIC_TEXT = "italic"
    CODE_TEXT = "code"
    LINK = "links"
    IMAGE = "images"

class TextNode:

    def __init__(self, text, text_type, url=None):
       self.text = text
       self.text_type = text_type
       self.url = url
    def __repr__(self):
        return f"TextNode({self.text}, {self.text_type.value}, {self.url})"

node1=TextNode("This is text with a `code block` word",TextType.PLAIN_TEXT)
node2=TextNode("This is text with a **bold text** word",TextType.PLAIN_TEXT)
node3=TextNode("This is text with a _italic text_ word",TextType.PLAIN_TEXT)
node4=TextNode("This is text with a `code block` word",TextType.BOLD_TEXT)
node5=TextNode("This is text with a `code block` word",TextType.ITALIC_TEXT)
node6=TextNode("This is text with a **bold fake word",TextType.PLAIN_TEXT)


nodes= [node1,node2,node3,node4,node5,node5]

random_string= "just long enough to split into 3"
str1 = random_string[:5]
str2 = random_string[5:8]
str3 = random_string[8:]
#print(str1)
#print(str2)
#print(str3)
#print(random_string)

def split_nodes_delimiter(old_nodes, delimiter, text_type):
    new_nodes = []
    for node in old_nodes:
        if node.text_type != TextType.PLAIN_TEXT:
            new_nodes.append(node)
            continue
        index1 = node.text.find(delimiter)
        if index1 == -1:
            new_nodes.append(node)
            continue
        index2 = node.text.find(delimiter, index1 +len(delimiter))
        if index2 == -1:
            raise Exception("That's invalid Markdown syntax")
        temp_nodes = node.text.split(f"{delimiter}")
        print(temp_nodes)
        
    print(len(new_nodes))
        
split_nodes_delimiter(nodes,"**", "text_type")



